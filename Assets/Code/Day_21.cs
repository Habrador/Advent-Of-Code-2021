using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Day_21 : MonoBehaviour
{
    private static long numberOfUniverses = 0;

    private static bool isGameFinished = false;



    private void Start()
    {
        //Part_1();

        Part_2();
    }

    

    private void Part_1()
    {
        //Input
        //Player 1 starting position: 1
        //Player 2 starting position: 6

        //Circular track 1-10
        //Roll a die 3 times, add up the sum, move so many steps
        //The total score is generated by adding up the steps each player ends up on after moving
        //You win after getting at least 1000 points
        

        //Example: 
        //Player 1 starting position: 4
        //Player 2 starting position: 8
        int player_1_pos = 4;
        int player_2_pos = 8;

        //Actual numbers 
        //int player_1_pos = 1;
        //int player_2_pos = 6;

        int player_1_score = 0;
        int player_2_score = 0;

        int numberOfDiceRolls = 0;

        int safety = 0;

        //The dice is 100 sided and starts at 1, then goes to 2, etc
        int diceValue = 1;

        bool isPlayer_1_winner = false;

        while (true)
        {
            safety += 1;

            if (safety > 10000000)
            {
                Debug.Log("Stuck in infinite loop");

                break;
            }


            //
            // Move player 1
            //
            player_1_pos += RollDice(ref diceValue);

            //But ClampListIndex is a list so goes 0-9, but our board goes 1-10
            player_1_pos = ClampListIndex(player_1_pos - 1, 10);

            player_1_pos += 1;

            player_1_score += player_1_pos;

            numberOfDiceRolls += 3;


            if (player_1_score >= 1000)
            {
                Debug.Log("Player 1 is the winner");

                isPlayer_1_winner = true;

                break;
            }


            //
            // Move player 2
            //
            
            player_2_pos += RollDice(ref diceValue);

            //But ClampListIndex is a list so goes 0-9, but our board goes 1-10
            player_2_pos = ClampListIndex(player_2_pos - 1, 10);

            player_2_pos += 1;

            player_2_score += player_2_pos;

            numberOfDiceRolls += 3;


            if (player_2_score >= 1000)
            {
                Debug.Log("Player 2 is the winner");

                break;
            }
        }



        int scoreOfLoser = isPlayer_1_winner ? player_2_score : player_1_score;

        int finalAnswer = scoreOfLoser * numberOfDiceRolls;

        Debug.Log($"Number of dice rolls: {numberOfDiceRolls}");

        Debug.Log($"Player 1 score: {player_1_score}");
        Debug.Log($"Player 2 score: {player_2_score}");


        //Should be 604998
        Debug.Log($"Final answer: {finalAnswer}");
    }



    private void Part_2()
    {
        //Input
        //Player 1 starting position: 1
        //Player 2 starting position: 6

        //Circular track 1-10
        //Roll a die 3 times, add up the sum, move so many steps
        //The total score is generated by adding up the steps each player ends up on after moving
        //You win after getting at least 27 points


        //Example: 
        //Player 1 starting position: 4
        //Player 2 starting position: 8
        int player_1_pos = 4;
        int player_2_pos = 8;

        //Actual numbers 
        //int player_1_pos = 1;
        //int player_2_pos = 6;

        int player_1_score = 0;
        int player_2_score = 0;



        //We need some kind of tree structure because using a recursive methods will not work because we want to generate all possible outcomes, not first possible best outcome.   

        //Or if we know how many universes we for a player to win, such as 5, by using recursive, then we should be able to calculate how big the tree is if we know its depth is 5??? Or maybe that first solution is wrong and another part of the tree could have generated a better solution!

        //We could also use a max-levels-expanded while keeping track of the min number of universes until we hit a goal

        //The dice is has 3 sides: 1, 2, 3
        PlayGame(player_1_pos, player_2_pos, player_1_score, player_2_score);








        //int scoreOfLoser = isPlayer_1_winner ? player_2_score : player_1_score;

        //int finalAnswer = scoreOfLoser * numberOfDiceRolls;

        //Debug.Log($"Number of dice rolls: {numberOfDiceRolls}");

        //Debug.Log($"Player 1 score: {player_1_score}");
        //Debug.Log($"Player 2 score: {player_2_score}");


        ////Should be 604998
        //Debug.Log($"Final answer: {finalAnswer}");
    }



    private void MovePlayers(int diceValue_player_1, int diceValue_player_2, int player_1_pos, int player_2_pos, int player_1_score, int player_2_score)
    {
        if (isGameFinished)
        {
            return;
        }


        numberOfUniverses += 1;

        if (numberOfUniverses > 544356092776315)
        {
            Debug.Log("Stuck in infinite loop");

            return;
        }


        //Move player 1
        player_1_pos += diceValue_player_1;

        //But ClampListIndex is a list so goes 0-9, but our board goes 1-10
        player_1_pos = ClampListIndex(player_1_pos - 1, 10) + 1;

        player_1_score += player_1_pos;

        //Debug.Log($"Player 1 score: {player_1_score}, Pos: {player_1_pos}");

        if (player_1_score >= 27)
        {
            Debug.Log("Player 1 is the winner");

            Debug.Log($"Number of Universes: {numberOfUniverses}");

            //isGameFinished = true;

            return;
        }


        //Move player 2
        player_2_pos += diceValue_player_2;

        //But ClampListIndex is a list so goes 0-9, but our board goes 1-10
        player_2_pos = ClampListIndex(player_2_pos - 1, 10) + 1;

        player_2_score += player_2_pos;

        if (player_2_score >= 27)
        {
            Debug.Log("Player 2 is the winner");

            Debug.Log($"Number of Universes: {numberOfUniverses}");

            //isGameFinished = true;

            return;
        }


        //Create a new universe
        PlayGame(player_1_pos, player_2_pos, player_1_score, player_2_score);
    }


    private void PlayGame(int player_1_pos, int player_2_pos, int player_1_score, int player_2_score)
    {
        //The dice is has 3 sides: 1, 2, 3

        MovePlayers(diceValue_player_1: 1, diceValue_player_2: 1, player_1_pos, player_2_pos, player_1_score, player_2_score);
        MovePlayers(diceValue_player_1: 1, diceValue_player_2: 2, player_1_pos, player_2_pos, player_1_score, player_2_score);
        MovePlayers(diceValue_player_1: 1, diceValue_player_2: 3, player_1_pos, player_2_pos, player_1_score, player_2_score);

        MovePlayers(diceValue_player_1: 2, diceValue_player_2: 1, player_1_pos, player_2_pos, player_1_score, player_2_score);
        MovePlayers(diceValue_player_1: 2, diceValue_player_2: 2, player_1_pos, player_2_pos, player_1_score, player_2_score);
        MovePlayers(diceValue_player_1: 2, diceValue_player_2: 3, player_1_pos, player_2_pos, player_1_score, player_2_score);

        MovePlayers(diceValue_player_1: 3, diceValue_player_2: 1, player_1_pos, player_2_pos, player_1_score, player_2_score);
        MovePlayers(diceValue_player_1: 3, diceValue_player_2: 2, player_1_pos, player_2_pos, player_1_score, player_2_score);
        MovePlayers(diceValue_player_1: 3, diceValue_player_2: 3, player_1_pos, player_2_pos, player_1_score, player_2_score);
    }



    private int RollDice(ref int diceValue)
    {
        //Roll the dice 3 times
        int diceSum = 0;

        for (int i = 0; i < 3; i++)
        {
            diceSum += diceValue;

            diceValue += 1;

            if (diceValue > 100)
            {
                diceValue = 1;
            }
        }

        return diceSum;
    }



    //Clamp list indices
    //Will even work if index is larger/smaller than listSize, so can loop multiple times
    public static int ClampListIndex(int index, int listSize)
    {
        index = ((index % listSize) + listSize) % listSize;

        return index;
    }
}
