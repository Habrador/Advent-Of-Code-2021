using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

public class Day_14 : MonoBehaviour
{
    private static int safety = 0;


    private void Start()
    {
        //Part_1();

        Part_2();
    }



    private void Part_2()
    {
        GetData("input.txt", out string polymerTemplate, out Dictionary<string, string> pairInsertionRules);


        //polymerTemplate = "NCN";

        //Get the 15 days template generated by using Part 1
        polymerTemplate = FileManagement.GetInputData("Day_14", "day_14_output.txt")[0];


        //The rule AB -> C means that when elements A and B are adjacent, a C should be inserted between them
        //The template is NNCB, which has 3 pairs: NN, NC, CB, and with the rules
        // NN -> C: NCN  
        // NC -> B: NBC
        // CB -> H: CHB
        //After step 1, we get NCNBCHB

        //How many times a character occurs in the template
        Dictionary<char, long> characterOccurances = new Dictionary<char, long>();

        //Count the characters in the start template
        foreach (char c in polymerTemplate)
        {
            if (!characterOccurances.ContainsKey(c))
            {
                characterOccurances[c] = 1;
            }
            else
            {
                characterOccurances[c] += 1;
            }
        }


        //There are many duplicates in the template, so to speed up the process, we should generate a lookup table
        Dictionary<string, Dictionary<char, long>> occurancesLookup = new Dictionary<string, Dictionary<char, long>>();

        //Generate the template while counting characters
        int MAX_STEPS = 25;

        foreach (KeyValuePair<string, string> insertionRules in pairInsertionRules)
        {
            string element = insertionRules.Key;
        
            Dictionary<char, long> insertionRulesOccurances = new Dictionary<char, long>();

            Insert(element, pairInsertionRules, insertionRulesOccurances, step: 0, MAX_STEPS);

            occurancesLookup[element] = insertionRulesOccurances;
        }

        //Loop through the template and add the count for each element to the total counter
        for (int j = 0; j < polymerTemplate.Length - 1; j++)
        {
            string element = polymerTemplate.Substring(j, 2);

            Dictionary<char, long> insertionRulesOccurances = occurancesLookup[element];

            foreach (KeyValuePair<char, long> count in insertionRulesOccurances)
            {
                char c = count.Key;

                if (!characterOccurances.ContainsKey(c))
                {
                    characterOccurances[c] = count.Value;
                }
                else
                {
                    characterOccurances[c] += count.Value;
                }
            }
        }

        //We cant display the final template because we are just counting the characters in the template to speed up the process
        //The final string we be really big so we can't generate it anyway
        //Debug.Log($"Final template: {polymerTemplate}");



        //
        // Calculate the final answer
        //

        //Find the max and min occurances
        long max = -long.MaxValue;
        long min = long.MaxValue;

        foreach (KeyValuePair<char, long> pair in characterOccurances)
        {
            if (pair.Value > max)
            {
                max = pair.Value;
            }
            if (pair.Value < min)
            {
                min = pair.Value;
            }
        }


        long finalAnswer = max - min;

        //Should be 2265039461737
        Debug.Log($"Final answer: {finalAnswer}");
    }



    //Insert character between two elements
    private void Insert(string element, Dictionary<string, string> pairInsertionRules, Dictionary<char, long> characterOccurances, int step, int MAX_STEPS)
    {
        safety += 1;

        //if (safety > 1000000)
        //{
        //    Debug.Log("Stuck in infinite loop");
        //    return;
        //}

        //Find which character to insert
        string characterToInsert = pairInsertionRules[element];

        //Debug.Log(characterToInsert);

        //Count how many times we have seen this character
        char c = char.Parse(characterToInsert);

        if (!characterOccurances.ContainsKey(c))
        {
            characterOccurances[c] = 1;
        }
        else
        {
            characterOccurances[c] += 1;
        }

        //Continue the process if we have more steps
        step += 1;

        if (step >= MAX_STEPS)
        {
            return;
        }

        string newElement = element.Insert(1, characterToInsert);

        string newElement_1 = newElement.Substring(0, 2);
        string newElement_2 = newElement.Substring(1, 2);

        Insert(newElement_1, pairInsertionRules, characterOccurances, step, MAX_STEPS);
        Insert(newElement_2, pairInsertionRules, characterOccurances, step, MAX_STEPS);
    }



    private void Part_1()
    {
        GetData("input.txt", out string polymerTemplate, out Dictionary<string, string> pairInsertionRules);


        //The rule AB -> C means that when elements A and B are adjacent, a C should be inserted between them
        //The template is NNCB, which has 3 pairs: NN, NC, CB, and with the rules
        // NN -> C: NCN  
        // NC -> B: NBC
        // CB -> H: CHB
        //After step 1, we get NCNBCHB

        int STEPS = 10;

        for (int i = 0; i < STEPS; i++)
        {
            List<string> newElements = new List<string>();

            for (int j = 0; j < polymerTemplate.Length - 1; j++)
            {
                string element = polymerTemplate.Substring(j, 2);
                //Debug.Log(element);
                string characterToInsert = pairInsertionRules[element];

                string newElement = element.Insert(1, characterToInsert);

                newElements.Add(newElement);
            }

            //Combine into one string
            string newPolymerTemplateString = "";

            for (int j = 0; j < newElements.Count; j++)
            {
                if (j == 0)
                {
                    newPolymerTemplateString += newElements[j];
                }
                else
                {
                    newPolymerTemplateString += newElements[j].Substring(1, 2);
                }
            }

            polymerTemplate = newPolymerTemplateString;
        }

        Debug.Log($"Final template: {polymerTemplate}");


        //
        // To get the final answer we have to count characters
        //

        Dictionary<char, int> characterOccurances = new Dictionary<char, int>();

        foreach (char c in polymerTemplate)
        {
            if (!characterOccurances.ContainsKey(c))
            {
                characterOccurances[c] = 1;
            }
            else
            {
                characterOccurances[c] += 1;
            }
        }

        //Find the max and min occurances
        int max = -int.MaxValue;
        int min =  int.MaxValue;

        foreach (KeyValuePair<char, int> pair in characterOccurances)
        {
            if (pair.Value > max)
            {
                max = pair.Value;
            }
            if (pair.Value < min)
            {
                min = pair.Value;
            }
        }


        int finalAnswer = max - min;

        //Should be 2027
        Debug.Log($"Final answer: {finalAnswer}");


        //Save the string for use to speed up part 2
        string fullPath = "C:/tmp/day_14_output.txt";

        //File.WriteAllLines(fullPath, );

        File.WriteAllText(fullPath, polymerTemplate);
    }



    private void GetData(string fileName, out string polymerTemplateString, out Dictionary<string, string> pairInsertionRules)
    {
        //Get the data 
        string[] allRowsString = FileManagement.GetInputData("Day_14", fileName);

        //Data consists of two sections separated by an empty row
        //Section 1: PPFCHPFNCKOKOSBVCFPP
        //Section 2: Rows of VC -> N

        polymerTemplateString = "";
        List<string> pairInsertionRulesStrings = new List<string>();

        bool hasFoundSpace = false;

        foreach (string row in allRowsString)
        {
            if (row.Length == 0)
            {
                hasFoundSpace = true;
            }
            else if (!hasFoundSpace)
            {
                polymerTemplateString = row;
            }
            else
            {
                pairInsertionRulesStrings.Add(row);
            }
        }

        //Debug.Log(polymerTemplateString);
        //Debug.Log(pairInsertionRulesStrings[0]);
        //Debug.Log(pairInsertionRulesStrings[pairInsertionRulesStrings.Count - 1]);

        pairInsertionRules = new Dictionary<string, string>();

        foreach (string s in pairInsertionRulesStrings)
        {
            string[] separator = { "->" };

            string[] rules = s.Split(separator, StringSplitOptions.RemoveEmptyEntries);

            //Important to Trim() to avoid all leading and trailing white-space characters!
            pairInsertionRules[rules[0].Trim()] = rules[1].Trim();
        }

        //foreach (KeyValuePair<string, string> pairs in pairInsertionRules)
        //{
        //    Debug.Log(pairs.Key + ": " + pairs.Value);
        //}

        //Debug.Log(pairInsertionRules["NN"]);
    }
}
